game design doc.
quick facts:
i want to be done with this in a weekish.
this doc isn't totally complete or fully specified, but represents a reasonably current snapshot of my thinking

the big idea is:

irl:
scarce natural resources
survival requires transforming natural resources
exploration and/or violence are used to expand resource access
fixed + variable production costs
technological progress increases production, shifts burden to fixed costs

in game, same ideas.
likely will be a ~1000x1000 grid of autogenerated terrain. will probably adjust size but plan for this OOM (1m tiles)
50x50 or so viewport of the world (fog of war).
the inhabitants of the world will be LLMs. something like 5-20x players per 'cluster', with a few clusters/world.
the LLMs will start with either a specific prompt/utility fn or be left to their own devices.
the goal is to produce interesting/fun micro/macro situations.
watch as on the small scale, towns form and disband, players form relationships and search for meaning.
on the large scale, maybe certain clusters of players realize they need to progress down the tech tree for fear of violent invasion from other resource-hungry towns.
game time progresses a la civ 5. i.e. every player chooses some actions for their turn, the turn ends, state updates/'ticks', and go to next turn
some actions don't end a turn: moving, chatting, etc.
some actions do end a turn; i.e. harvesting/crafting/attacking/etc
turns will happen in 'groups' based on player proximity.
suppose there are two clusters of players, far apart on the map.
nearby players in a cluster need to move sequentially to avoid state conflicts.
but e.g. P1 in cluster 1 and P2 in cluster 2 can move simultaneously, since they wont impact each other's game state.
this can be determined by like max_effect_range() or something. to start, it'd just be := view_distance + movement_range or something
combat will not be the main focus, but is a realistic aspect of society building that would be a huge omission.
something like risk-like dice rolls, where damage is done based on the quality of weaponry equipped.



tiles:
grassland, forest, desert, mountain, ore, water


structures/entities:
farm:
    requires:
        grassland + mats
    stats:
        health, yield, growth
    actions:
        tend, harvest -> food

mine:
    requires:
        ore + mats
    stats:
        richness, yield, efficiency
    actions:
        extract -> metals

warehouse:
    stats:
        capacity
    actions:
        store, retrieve

road:
    requires:
        mats

buildings/products:
tier 1 factory:
    requires:
        tier 1 mats
    recipes:
        production 1: (metals/timber -> equipment, goods)
        production 2: (metals/timber -> equipment, goods)
        production 2: (metals/timber -> equipment, goods)

armory:
    requires:
        equipment, goods
    recipes:
        work -> (metals/timber -> weaponry)

house:
    requires:
        tools, goods (many)
    stats:
        occupancy (aka cooldown on reproducing)
    actions:
        reproduce -> (2x player -> 3x player)

library:
    requires:
        tools, goods
    stats:
        occupancy (more people per library -> faster tech unlocks; sigmoidal)
    actions:
        study -> lvl up knowledge; learn recipe for better buildings

sample game
    'forage' in forest & ore patches to get a few timber/metals
    'forage' will also net a tiny amount of food to avoid pre-farm starving
    craft primitive tools (doesn't need building)
    use primitive tools to build a farm, start tending it
    use primitive tools to build a mine
    generate more metals from the new mines
    generate more timber by 'harvesting' in a forest with actual tools
    build a primitive civilian factory to produce tools more efficiently, also unlocks goods
    use newly generated goods to build houses, start growing population
    continue gathering resources
    build library and dedicate someone to start skilling up the tech tree
    make better tools in current tier factory
    choose b/w upgrading mines/farms/factories/armories or building roads
    trade with other individuals or bands of players 
    repeat

technical needs/concerns:
    1. the entire game state needs to be projectable into text-space for LLMs
    2. we need to support serializing/deserializing potentially on the order of 1M tiles
    3. most of the wall clock time will be spent waiting for LLM replies, so perf is secondary
    4. the code should be easily extensible so we can add future game mechanics
    5. we need to deal with potentially on the order of hundreds of LLM players
        a. we may be able to optimistically query >1 lm's for action choice at state S, retrying on conflict



hypothetical info panel:

Prompt:
<prompt>

Documentation:
<documentation>

Game Info:
Current Turn: 10

Player Info:
Name: scipio africanus
Sex: M
Health: 100/100
Hunger: 0/100
Location: 25, -22
Movement Points: 5 / 20 
Inventory:
    10x Primitive Materials
    4x Food
Skills:
    Farming: 0/100
    Mining: 10/100
    Forestry: 30/100
    Production: 70/100
    Warfare: 60/100

Journal:
1) note to self: need to tend farmland asap
2) ...

Map View:
<rendered map>

Events This Turn:
1. player 'marcus agrippa' moved into view, now at 30,22
2. player 'marcus agrippa' said "i'm going mining up north, would someone mind tending the farm?"
3. you whispered player 'marcus agrippa' with the message 'i don't think that would be a good idea'

Structures in View:
Primitive Farm:
    id: structure-30
    Position:
        world: 30, -24
        relative: +5, -2
        distance: 7
    Health: 90/100
    Last Tended: 7 turns ago
    Growth Progress: 6/10
    Harvest Yield: 0 Food
    Available Actions: None
    Unavailable Actions:
        'Destroy Farm' (out of range)


Available Actions:
1) move towards world coordinate 
2) move in relative direction
3) say something out loud
4) whisper player 'marcus agrippa' something

3) move to primtive farm (id: structure-30)
4) destroy primitive farm


....
Sample Json Actions:
{
    'action': 'move_towards_world_coordinate',
    'arguments': {'x': 30, 'y': 30}
}
{
    'action': 'select_action',
    'arguments': {'selected_action': 2}
}



main game loop pseudocode (somewhat dated):


S = WorldState()
main:
    groups = graphSplitPlayers(S.players)   // connected subgraphs where nodes are players, edges if within movement + view range, to ensure no race conditions
    for group in groups:                    // .. race conditions wouldn't crash us, but would poison llm context windows with stale/invalid state
        await runGroupTurn(S, group)


async runGroupTurn(S, players):
    queue = new Queue()
    insertInRandomOrder(queue, players)
    while notEmpty(queue):
        player = queue.pop()
        turn_ended = await runPlayerTurn(S, player, retries=2)
        if not turn_ended:
            queue.insert(player)
            

async runPlayerTurn(S, player, retries):
    if retries == 0 return true
    view = computeViewFor(S, player)                        // ideally, just data; serializable and http-sendable
    actions = await choose_actions(player, view, GAME_CONFIG)
    for action in actions:
        ok, err = execute_action(S, action)                      // atomic on the 1-action level; either it succeeds or does nothing
        if not ok:
            log_error(err, S, player, action, actions)
            await runPlayerTurn(S, player, retries - 1)
    

type View {
    tilesInView,
    structuresInView,
    playersInView,
    
}


code/style notes:
    - C style where possible, prefer enums, interfaces, types for data
    - pure functions where possible
example:
    writing choose_action(player,view,config)
    this way, we can have some sort of LLM inference handler available in that function
    switch on player id, call associated function
    or something like that.
    lets us differentiate by model types
    or later, can just plug in wait_for_client_response
    versus Player.choose_action where then we need the logic to live on the player
    the logic that lives on the player could also just call wait_for_client_response
    but this seems cleaner? idk.



entrypoints, 'real' main fn, usage:

village
    lists help, config values, available saves

village new <path>
    makes a new game save at 'path'

village view <path> <player_id>
    shows view as json for 'player_id', defaulting to spectator (global) view

village exec <path>
    tries executing actions from stdin, shows resulting gamelog or errors

village advance <path> <player_id>
    progresses the game state until player_id's turn

village run <path> <n_turns (optional)>
    run game in loop, printing to console, exiting after n_turns or until game is halted or sigkill













